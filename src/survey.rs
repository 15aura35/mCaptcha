// Copyright (C) 2022  Aravinth Manivannan <realaravinth@batsense.net>
// SPDX-FileCopyrightText: 2023 Aravinth Manivannan <realaravinth@batsense.net>
//
// SPDX-License-Identifier: AGPL-3.0-or-later
use std::collections::HashMap;
use std::sync::Arc;
use std::sync::RwLock;
use std::time::Duration;

use reqwest::Client;
use serde::{Deserialize, Serialize};
use tokio::task::JoinHandle;
use tokio::time::sleep;

use crate::errors::*;
use crate::settings::Settings;
use crate::AppData;

#[async_trait::async_trait]
trait SurveyClientTrait {
    async fn start_job(&self, data: AppData) -> ServiceResult<JoinHandle<()>>;
    async fn register(&self, data: &AppData) -> ServiceResult<()>;
}

#[derive(Clone, Debug, Default)]
pub struct SecretsStore {
    store: Arc<RwLock<HashMap<String, String>>>,
}

impl SecretsStore {
    pub fn get(&self, key: &str) -> Option<String> {
        let r = self.store.read().unwrap();
        r.get(key).map(|x| x.to_owned())
    }

    pub fn rm(&self, key: &str) {
        let mut w = self.store.write().unwrap();
        w.remove(key);
        drop(w);
    }

    pub fn set(&self, key: String, value: String) {
        let mut w = self.store.write().unwrap();
        w.insert(key, value);
        drop(w);
    }
}

struct Survey {
    settings: Settings,
    client: Client,
    secrets: SecretsStore,
}
impl Survey {
    fn new(settings: Settings, secrets: SecretsStore) -> Self {
        Survey {
            client: Client::new(),
            settings,
            secrets,
        }
    }
}

#[async_trait::async_trait]
impl SurveyClientTrait for Survey {
    async fn start_job(&self, data: AppData) -> ServiceResult<JoinHandle<()>> {
        let fut = async move {
            loop {
                sleep(Duration::new(data.settings.survey.rate_limit, 0)).await;
                //                if let Err(e) = Self::delete_demo_user(&data).await {
                //                    log::error!("Error while deleting demo user: {:?}", e);
                //                }
                //                if let Err(e) = Self::register_demo_user(&data).await {
                //                    log::error!("Error while registering demo user: {:?}", e);
                //                }
            }
        };
        let handle = tokio::spawn(fut);
        Ok(handle)
    }
    async fn register(&self, data: &AppData) -> ServiceResult<()> {
        let protocol = if self.settings.server.proxy_has_tls {
            "https://"
        } else {
            "http://"
        };
        #[derive(Serialize)]
        struct MCaptchaInstance {
            url: url::Url,
            secret: String,
        }

        let this_instance_url =
            url::Url::parse(&format!("{protocol}{}", self.settings.server.domain))?;
        for url in self.settings.survey.nodes.iter() {
            // mCaptcha/survey must send this token while uploading secret to authenticate itself
            // this token must be sent to mCaptcha/survey with the registration payload
            let secret_upload_auth_token = crate::api::v1::mcaptcha::get_random(20);

            let payload = MCaptchaInstance {
                url: this_instance_url.clone(),
                secret: secret_upload_auth_token.clone(),
            };

            // SecretsStore will store auth tokens generated by both mCaptcha/mCaptcha and
            // mCaptcha/survey
            //
            // Storage schema:
            // - mCaptcha/mCaptcha generated auth token: (<auth_token>, <survey_instance_url>)
            // - mCaptcha/survey generated auth token (<survey_instance_url>, <auth_token)
            self.secrets.set(secret_upload_auth_token, url.to_string());
            self.client
                .post(url.clone())
                .json(&payload)
                .send()
                .await
                .unwrap();
        }
        Ok(())
    }
}
